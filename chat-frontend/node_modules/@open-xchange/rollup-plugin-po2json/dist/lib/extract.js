import ts from 'typescript';
import PO from 'pofile';
import { itemKey } from '../util/util.js';
// expected gettext module name in import statements of parsed code
const IMPORT_MODULE_NAME = 'gettext'; // TODO: make configurable?
function walk(node, cb) {
    cb(node);
    ts.forEachChild(node, child => walk(child, cb));
}
function isImportDeclaration(node) {
    return node.kind === ts.SyntaxKind.ImportDeclaration;
}
function isNamedImports(node) {
    return node.kind === ts.SyntaxKind.NamedImports;
}
function isCallExpression(node) {
    return node.kind === ts.SyntaxKind.CallExpression;
}
function isMemberExpression(node) {
    return node.kind === ts.SyntaxKind.PropertyAccessExpression;
}
function isBinaryExpression(node) {
    return node.kind === ts.SyntaxKind.BinaryExpression;
}
function isIdentifier(node) {
    return node.kind === ts.SyntaxKind.Identifier;
}
function isStringLiteral(node) {
    return node.kind === ts.SyntaxKind.StringLiteral;
}
function isString(value) {
    return typeof value === 'string';
}
function getStringLiteral(node) {
    return isStringLiteral(node) ? node.text : undefined;
}
function resolveStringExpression(node) {
    if (isBinaryExpression(node) && node.operatorToken.kind === ts.SyntaxKind.PlusToken) {
        const leftValue = resolveStringExpression(node.left);
        const rightValue = getStringLiteral(node.right);
        return (isString(leftValue) && isString(rightValue)) ? (leftValue + rightValue) : undefined;
    }
    return getStringLiteral(node);
}
export function extractItems(id, code) {
    // let TypeScript parse the source code
    const sourceFile = ts.createSourceFile(id, code, ts.ScriptTarget.ESNext);
    // all comments starting with '#', mapped by line number
    const comments = new Map();
    // extracts the text of comments from TS comment ranges
    function processCommentRanges(commentRanges) {
        if (commentRanges) {
            for (const commentRange of commentRanges) {
                const block = commentRange.kind === ts.SyntaxKind.MultiLineCommentTrivia;
                const comment = code.slice(commentRange.pos, commentRange.end);
                const text = comment.replace(block ? /^\/\*|\*\/$/g : /^\/\//, '').trim();
                if (text.startsWith('#')) {
                    const { line } = sourceFile.getLineAndCharacterOfPosition(commentRange.pos);
                    comments.set(line, { text, block });
                }
            }
        }
    }
    // names of identifiers used as 'gettext' function names
    const identifiers = new Set();
    // the extracted PO items
    const items = new Map();
    const mapOfSets = new Map();
    walk(sourceFile, node => {
        // collect all comments surrounding the node
        processCommentRanges(ts.getLeadingCommentRanges(code, node.getFullStart()));
        processCommentRanges(ts.getTrailingCommentRanges(code, node.pos));
        // collect all import statements used as 'gt' function
        if (isImportDeclaration(node)) {
            // skip side effect or type imports
            if (node.importClause && !node.importClause.isTypeOnly) {
                const source = getStringLiteral(node.moduleSpecifier);
                // module name may be followed by query string
                if (source === IMPORT_MODULE_NAME || source?.startsWith(IMPORT_MODULE_NAME + '?')) {
                    // default import
                    const defaultImport = node.importClause.name;
                    if (defaultImport && !node.importClause.isTypeOnly)
                        identifiers.add(defaultImport.text);
                    // named imports
                    const bindings = node.importClause.namedBindings;
                    if (bindings && isNamedImports(bindings)) {
                        for (const element of bindings.elements) {
                            if (!element.isTypeOnly)
                                identifiers.add(element.name.text);
                        }
                    }
                }
            }
            return;
        }
        if (isCallExpression(node)) {
            let id;
            let msgctxt;
            let msgid;
            let msgidPlural;
            const callExpression = node.expression;
            const argsCount = node.arguments.length;
            // simple function call, e.g. `gt('string')`
            if (isIdentifier(callExpression) && argsCount >= 1) {
                id = callExpression.text;
                msgid = resolveStringExpression(node.arguments[0]);
            }
            // simple member call, e.g. `gt.pgettext('context', 'string')`
            if (isMemberExpression(callExpression) && isIdentifier(callExpression.expression) && isIdentifier(callExpression.name)) {
                id = callExpression.expression.text;
                switch (callExpression.name.text) {
                    case 'pgettext':
                        if (argsCount >= 2) {
                            msgctxt = getStringLiteral(node.arguments[0]);
                            msgid = resolveStringExpression(node.arguments[1]);
                        }
                        break;
                    case 'ngettext':
                        if (argsCount >= 2) {
                            msgid = resolveStringExpression(node.arguments[0]);
                            msgidPlural = resolveStringExpression(node.arguments[1]);
                        }
                        break;
                    case 'npgettext':
                        if (argsCount >= 3) {
                            msgctxt = getStringLiteral(node.arguments[0]);
                            msgid = resolveStringExpression(node.arguments[1]);
                            msgidPlural = resolveStringExpression(node.arguments[2]);
                        }
                        break;
                }
            }
            if (id && msgid) {
                const item = new PO.Item();
                item.msgctxt = msgctxt;
                item.msgid = msgid;
                item.msgid_plural = msgidPlural;
                // extract comments and flags
                const start = sourceFile.getLineAndCharacterOfPosition(node.getStart(sourceFile)).line;
                for (let line = start; true; line--) {
                    const comment = comments.get(line);
                    comments.delete(line);
                    if (!comment && (line === start))
                        continue; // comment may be missing on same line
                    if (!comment || (comment.block && line < start))
                        break; // exit loop if no more line comments available
                    const marker = comment.text.slice(0, 2);
                    const text = comment.text.slice(2).trim();
                    switch (marker) {
                        case '#.':
                            item.extractedComments.unshift(text);
                            break;
                        case '#,':
                            item.flags[text] = true;
                            break;
                    }
                }
                // automatically add 'c-format' flag when using placeholders in the message
                const regex = /%([idufFgG]|\d+\$)/;
                if (item.msgid.match(regex) || item.msgid_plural?.match(regex)) {
                    item.flags['c-format'] = true;
                }
                let itemSet = mapOfSets.get(id);
                if (!itemSet)
                    mapOfSets.set(id, itemSet = []);
                itemSet.push(item);
            }
        }
    });
    identifiers.forEach(id => {
        mapOfSets.get(id)?.forEach(item => {
            items.set(itemKey(item), item);
        });
    });
    return items;
}
