import { dataToEsm, normalizePath } from '@rollup/pluginutils';
import PO from 'pofile';
import { readdir, readFile } from 'node:fs/promises';
import path from 'node:path';
import { PROJECT_NAME, itemKey, AmbiguousPluralFormException } from './util/util.js';
import { namespacesFrom, render, parsePoFile } from './lib/po2json.js';
import { extractItems } from './lib/extract.js';
export { PROJECT_NAME, parsePoFile, namespacesFrom };
export default function gettextPlugin(options) {
    const resolvedOptions = {
        outFile: 'i18n.pot',
        defaultDictionary: 'i18n',
        defaultLanguage: 'en_US',
        headers: {
            'Content-Type': 'text/plain; charset=UTF-8',
            'Content-Transfer-Encoding': '8bit'
        },
        includeFuzzy: false,
        ...options
    };
    let resolvedConfig;
    const { poFiles, outFile, defaultDictionary, defaultLanguage } = resolvedOptions;
    const dictionaries = new Set([defaultDictionary]);
    const codeMap = new Map();
    return {
        name: PROJECT_NAME,
        meta: resolvedOptions,
        configResolved(config) {
            resolvedConfig = config;
        },
        async buildStart() {
            const poDir = path.dirname(poFiles);
            const [file] = (await readdir(poDir)).filter(f => f.indexOf(defaultLanguage) >= 0).map(f => normalizePath(`${poDir}/${f}`));
            const po = await parsePoFile(file);
            for (const namespace of namespacesFrom(po.items)) {
                if (namespace !== defaultDictionary)
                    dictionaries.add(namespace);
            }
        },
        resolveId(id) {
            if (/^gettext$/.test(id)) {
                const meta = { gettext: { dictionary: false } };
                return { id: `${defaultDictionary}.js`, meta };
            }
            const gettextModuleMatch = id.match(/gettext\?.*dictionary=([^&]+)/);
            if (gettextModuleMatch) {
                dictionaries.add(gettextModuleMatch[1].replace(/\.js$/, ''));
                const meta = { gettext: { dictionary: false } };
                return { id: gettextModuleMatch[1].replace(/(\.js)?$/, '.js'), meta };
            }
            if (dictionaries.has(id.replace(/\.js$/, ''))) {
                const meta = { gettext: { dictionary: true } };
                return { id, meta };
            }
            const match = id.match(/(.*)\.([a-zA-Z]{2}_[a-zA-Z]{2})(\.js)?$/);
            const [, namespace, language] = match || [];
            return (namespace && language) ? id : null;
        },
        async resolveDynamicImport(_node, importer) {
            if (!dictionaries.has(importer.replace(/^\//, '').replace(/\.js$/, '')))
                return;
            const poDir = path.dirname(poFiles);
            const files = (await readdir(poDir)).map(f => normalizePath(`${poDir}/${f}`));
            for (const file of files) {
                const language = (file.match(/([^/]+).po$/) || [])[1];
                for (const namespace of dictionaries) {
                    if (!language)
                        continue;
                    this.emitFile({
                        type: 'chunk',
                        id: `${namespace}.${language}.js`,
                        fileName: `${namespace}.${language}.js`,
                        preserveSignature: 'strict'
                    });
                }
            }
        },
        transform: {
            order: 'pre',
            handler(code, id) {
                codeMap.set(id, code);
            }
        },
        async load(id) {
            const dictionary = id.replace(/\\/g, '/').replace(/^\.?\//, '').replace(/\.js$/, '');
            if (dictionaries.has(dictionary)) {
                const poDir = path.dirname(poFiles);
                const languages = (await readdir(poDir)).map(f => (f.match(/([^/]+).po$/) || [])[1]).filter(a => Boolean(a));
                const code = (await readFile(new URL('./lib/dictionary.js', import.meta.url))).toString()
                    .replaceAll('__dict_module__', `${dictionary}.${defaultLanguage}`)
                    .replaceAll('{{namespace}}', dictionary)
                    .replaceAll('{{defaultLanguage}}', defaultLanguage)
                    .replaceAll(/['"]{{languages}}['"]/g, languages.map(lang => `'${lang}'`).join(', '));
                return { meta: { gettext: { dictionary: true } }, code };
            }
            const match = id.match(/\.?\/?(.*)\.([a-zA-Z]{2}_[a-zA-Z]{2})(\.js)?$/);
            const [, namespace, language] = match || [];
            if (!namespace || !language || !dictionaries.has(namespace))
                return;
            const filename = normalizePath(`${path.dirname(poFiles)}/${language}.po`);
            const chunk = render(await parsePoFile(filename), options);
            return dataToEsm(chunk);
        },
        buildEnd() {
            // optimize for vite development mode, no need to do anything on buildEnd (server stop)
            if (resolvedConfig?.mode === 'development')
                return;
            const po = new PO();
            Object.assign(po.headers, resolvedOptions.headers);
            const gettextImporters = () => {
                const importers = new Set();
                for (const id of this.getModuleIds()) {
                    const moduleInfo = this.getModuleInfo(id);
                    if (moduleInfo && moduleInfo.meta.gettext?.dictionary) {
                        for (const importer of moduleInfo.importers) {
                            importers.add(importer);
                        }
                    }
                }
                return importers;
            };
            const allItems = new Map();
            for (const importer of gettextImporters()) {
                const moduleInfo = this.getModuleInfo(importer);
                const code = moduleInfo && codeMap.get(moduleInfo.id);
                if (code) {
                    for (const [key, msgItem] of extractItems(moduleInfo.id, code)) {
                        let item = allItems.get(key);
                        if (!item)
                            allItems.set(key, item = msgItem);
                        // add module reference
                        item.references.push(normalizePath(path.relative(process.cwd(), moduleInfo.id)));
                        // merge extracted comments
                        for (const comment of msgItem.extractedComments) {
                            if (item.extractedComments.filter(c => c === comment).length === 0)
                                item.extractedComments.push(comment);
                        }
                        // merge flags
                        Object.assign(item.flags, msgItem.flags);
                    }
                }
            }
            for (const item of allItems.values()) {
                // detect colliding singular/plural
                if (item.msgid_plural) {
                    const collidingItem = allItems.get(itemKey(item, false));
                    if (collidingItem)
                        throw new AmbiguousPluralFormException(item, collidingItem);
                }
                if (options.defaultDictionary)
                    item.references.push(`module:${defaultDictionary}`);
                po.items.push(item);
            }
            this.cache.set('po', po);
        },
        generateBundle() {
            const po = this.cache.get('po');
            this.emitFile({
                name: outFile,
                fileName: outFile,
                type: 'asset',
                source: po.toString()
            });
        }
    };
}
