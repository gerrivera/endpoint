import { PROJECT_NAME, deepMergeObject, mergeManifests } from './util.js';
import manifestsPlugin from './plugins/manifests.js';
import relativePathsPlugin from './plugins/relative-paths.js';
import settingsPlugin from './plugins/settings.js';
import servePlugin from './plugins/serve.js';
import gettextPlugin from './plugins/gettext.js';
import metaPlugin from './plugins/meta.js';
export { PROJECT_NAME, mergeManifests };
/**
 * Creates a vite-plugin to include manifests in dev and production mode
 */
export default function pluginOxManifests(options) {
    const resolvedOptions = {
        watch: false,
        entryPoints: '',
        manifestsAsEntryPoints: true,
        autoloadSettings: true,
        supportedEntryExtensions: ['js', 'mjs', 'ts'],
        meta: null,
        ...options
    };
    let resolvedConfig;
    const plugins = [
        // add settings first
        settingsPlugin(resolvedOptions),
        relativePathsPlugin(resolvedOptions),
        servePlugin(resolvedOptions),
        gettextPlugin(resolvedOptions),
        metaPlugin(resolvedOptions),
        // manifest plugin last
        manifestsPlugin(resolvedOptions)
    ];
    const pluginManifests = {
        name: PROJECT_NAME,
        enforce: 'post',
        async config(config, env) {
            for (const plugin of plugins) {
                plugin.pluginResolved?.(pluginManifests);
                if (typeof plugin.config === 'function') {
                    config = (await plugin.config.call(this, config, env)) || config;
                }
                else if (plugin.config) {
                    throw new TypeError(`object hooks not supported, specify function callback (${plugin.name}.config)`);
                }
            }
            return config;
        },
        async getManifests() {
            const manifests = [];
            for (const plugin of plugins) {
                if (plugin.getManifests) {
                    const result = await plugin.getManifests.call(this);
                    manifests.push(...result);
                }
            }
            return mergeManifests(manifests);
        },
        async configResolved(config) {
            resolvedConfig = config;
            for (const plugin of plugins) {
                if (typeof plugin.configResolved === 'function') {
                    await plugin.configResolved.call(this, config);
                }
                else if (plugin.configResolved) {
                    throw new TypeError(`object hooks not supported, specify function callback (${plugin.name}.configResolved)`);
                }
            }
        },
        async options(options) {
            if (resolvedConfig.mode === 'production') {
                options.preserveEntrySignatures = 'strict';
            }
            for (const plugin of plugins) {
                if (typeof plugin.options === 'function') {
                    options = (await plugin.options.call(this, options)) || options;
                }
                else if (plugin.options) {
                    throw new TypeError(`${plugin.name}.options: object hooks not supported, specify function callback`);
                }
            }
            return options;
        },
        async buildStart(options) {
            for (const plugin of plugins) {
                if (typeof plugin.buildStart === 'function') {
                    await plugin.buildStart.call(this, options);
                }
                else if (plugin.buildStart) {
                    throw new TypeError(`${plugin.name}.buildStart: object hooks not supported, specify function callback`);
                }
            }
        },
        async configureServer(server) {
            for (const plugin of plugins) {
                if (typeof plugin.configureServer === 'function') {
                    await plugin.configureServer.call(this, server);
                }
                else if (plugin.configureServer) {
                    throw new TypeError(`${plugin.name}.configureServer: object hooks not supported, specify function callback`);
                }
            }
        },
        async resolveId(source, importer, options) {
            for (const plugin of plugins) {
                if (typeof plugin.resolveId === 'function') {
                    const result = await plugin.resolveId.call(this, source, importer, options);
                    if (result !== undefined)
                        return result;
                }
                else if (plugin.resolveId) {
                    throw new TypeError(`${plugin.name}.resolveId: object hooks not supported, specify function callback`);
                }
            }
            return undefined;
        },
        async load(id) {
            for (const plugin of plugins) {
                if (typeof plugin.load === 'function') {
                    const result = await plugin.load.call(this, id);
                    if (result !== undefined)
                        return result;
                }
                else if (plugin.load) {
                    throw new TypeError(`${plugin.name}.load: object hooks not supported, specify function callback`);
                }
            }
            return undefined;
        },
        async transform(code, id) {
            let result = {};
            for (const plugin of plugins) {
                if (typeof plugin.transform === 'function') {
                    // TODO check what happens if there is already meta from other plugins
                    const that = await plugin.transform.call(this, code, id);
                    if (that && typeof that === 'object') {
                        result = deepMergeObject(result, that);
                    }
                }
                else if (plugin.transform) {
                    throw new TypeError(`${plugin.name}.transform: object hooks not supported, specify function callback`);
                }
            }
            return Object.keys(result).length ? result : undefined;
        },
        async generateBundle(options, bundle, isWrite) {
            for (const plugin of plugins) {
                if (typeof plugin.generateBundle === 'function') {
                    await plugin.generateBundle.call(this, options, bundle, isWrite);
                }
                else if (plugin.generateBundle) {
                    throw new TypeError(`${plugin.name}.generateBundle: object hooks not supported, specify function callback`);
                }
            }
        },
        async transformIndexHtml(src, ctx) {
            for (const plugin of plugins) {
                if (typeof plugin.transformIndexHtml === 'function') {
                    const result = await plugin.transformIndexHtml.call(this, src, ctx);
                    if (typeof result === 'string') {
                        src = result;
                    }
                    else if (result) {
                        throw new TypeError(`${plugin.name}.transformIndexHtml: tag descriptors not supported, return simple string`);
                    }
                }
                else if (plugin.transformIndexHtml) {
                    throw new TypeError(`${plugin.name}.transformIndexHtml: object hooks not supported, specify function callback`);
                }
            }
            return src;
        }
    };
    return pluginManifests;
}
