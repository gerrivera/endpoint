import { dirname, posix } from 'node:path';
import { readdir } from 'node:fs/promises';
import { normalizePath } from 'vite';
import { PROJECT_NAME as GETTEXT_PROJECT_NAME, parsePoFile, namespacesFrom } from '@open-xchange/rollup-plugin-po2json';
import { definePlugin } from './plugin.js';
import { PROJECT_NAME, applyInputToOptions } from '../util.js';
export default definePlugin(() => {
    const manifests = [];
    let resolvedConfig;
    return {
        name: `${PROJECT_NAME}/gettext-plugin`,
        configResolved(config) {
            resolvedConfig = config;
        },
        async options(options) {
            const gettextPlugin = resolvedConfig.plugins.find(plugin => plugin.name === GETTEXT_PROJECT_NAME);
            if (!gettextPlugin)
                return;
            const { meta: { poFiles, defaultDictionary, defaultLanguage } } = gettextPlugin;
            const input = {};
            // add dictionaries as entry points
            const poDir = dirname(poFiles);
            const files = (await readdir(poDir)).filter(f => f.indexOf(defaultLanguage) >= 0).map(f => normalizePath(`${poDir}/${f}`));
            await Promise.all(files.map(async (file) => {
                const po = await parsePoFile(file);
                for (const namespace of namespacesFrom(po.items)) {
                    if (namespace !== defaultDictionary) {
                        input[namespace] = `gettext?dictionary=${namespace}`;
                        manifests.push({ namespace: 'i18n', path: namespace });
                    }
                }
            }));
            input[defaultDictionary] = 'gettext';
            manifests.push({ namespace: 'i18n', path: defaultDictionary });
            if (resolvedConfig.mode === 'production') {
                applyInputToOptions(input, options);
            }
            return options;
        },
        getManifests() {
            if (resolvedConfig.mode === 'production')
                return manifests;
            return manifests.map(manifest => ({ ...manifest, raw: posix.join(resolvedConfig.base, `/@id/${manifest.path}.js`) }));
        },
        generateBundle(_options, bundle) {
            for (const file in bundle) {
                const chunk = bundle[file];
                if (chunk.type !== 'chunk' || !chunk.facadeModuleId)
                    continue;
                const modules = Object.keys(chunk.modules);
                if (modules.length === 0)
                    modules.push(chunk.facadeModuleId);
                for (const id of modules) {
                    const meta = this.getModuleInfo(id)?.meta;
                    if (meta?.gettext?.dictionary === true) {
                        (meta.manifests ??= []).push({ namespace: 'i18n', path: '' });
                    }
                }
            }
        }
    };
});
