import fs from 'node:fs/promises';
import path, { posix } from 'node:path';
import fastGlob from 'fast-glob';
import { PROJECT_NAME as EXTERNALS_PROJECT_NAME } from '@open-xchange/vite-plugin-ox-externals';
import { definePlugin } from './plugin.js';
import { PROJECT_NAME, applyInputToOptions, basepath } from '../util.js';
function shiftSet(set) {
    const result = set.values().next();
    if (result.done)
        return;
    set.delete(result.value);
    return result.value;
}
function assignSet(set, values) {
    for (const value of values)
        set.add(value);
}
function getRequirements(context, entry) {
    let moduleInfo = context.getModuleInfo(entry);
    if (!moduleInfo)
        return [];
    const open = new Set([...moduleInfo.importers, ...moduleInfo.dynamicImporters]);
    const closed = new Set(open);
    const entryPoints = [];
    for (;;) {
        const first = shiftSet(open);
        if (first === undefined)
            break;
        if (first.includes('node_modules'))
            continue;
        moduleInfo = context.getModuleInfo(first);
        if (!moduleInfo)
            continue;
        if (moduleInfo.isEntry) {
            const { manifests } = moduleInfo.meta;
            if (manifests) {
                entryPoints.push(...manifests.map(manifest => ({ requires: 'true', ...manifest })));
                continue;
            }
        }
        const nextOpen = [...moduleInfo.importers, ...moduleInfo.dynamicImporters].filter(o => !closed.has(o));
        assignSet(closed, nextOpen);
        assignSet(open, nextOpen);
    }
    return [...new Set(entryPoints.map(e => e.requires).filter(Boolean))];
}
function mergeRequirements(requirements) {
    if (requirements.length === 0)
        return;
    if (requirements.includes('true'))
        return;
    // check if is just a simple string
    return requirements.map(req => /^[-\w]*$/.test(req) ? req : `(${req})`).join('||');
}
export default definePlugin(({ autoloadSettings }) => {
    const settingsModules = new Map();
    let resolvedConfig;
    let externalPrefix;
    let moduleGraph;
    async function isSettingsFile(entry) {
        const containsSettingsRegex = new RegExp(`import.+[,\\s]Settings.+from ['"][@${externalPrefix}]\\/io.ox\\/core\\/settings(\\.js)?['"]`);
        const containsExportRegex = /export const settings = new Settings\(/;
        const content = await fs.readFile(entry, { encoding: 'utf-8' });
        // special case
        if (entry === `${resolvedConfig.root}/io.ox/core/settings.js`)
            return true;
        return containsSettingsRegex.test(content) && containsExportRegex.test(content);
    }
    return {
        name: `${PROJECT_NAME}/settings-plugin`,
        configResolved(config) {
            resolvedConfig = config;
            const externalPlugin = resolvedConfig.plugins.find(plugin => plugin.name === EXTERNALS_PROJECT_NAME);
            externalPrefix = externalPlugin ? externalPlugin.meta.prefix : '';
        },
        async options(options) {
            if (!autoloadSettings)
                return;
            const input = {};
            const root = resolvedConfig.root;
            const entries = await fastGlob(`${root.replace(/\\/g, '/')}/**/*.{js,ts,mjs}`, { absolute: true });
            await Promise.all(entries.map(async (entry) => {
                if (!await isSettingsFile(entry))
                    return;
                settingsModules.set(entry, { namespace: 'settings', path: '', generator: 'settings' });
                const baseLength = root.length + 1;
                const extLength = path.extname(entry).length;
                const entryPath = entry.substring(baseLength, entry.length - extLength);
                input[entryPath] = entry;
            }));
            if (resolvedConfig.mode === 'production') {
                applyInputToOptions(input, options);
            }
            return options;
        },
        configureServer(server) {
            moduleGraph = server.moduleGraph;
        },
        // specific call to collect all manifests
        getManifests() {
            return Array.from(settingsModules, ([path, manifest]) => {
                manifest.path = basepath(path.slice(resolvedConfig.root.length + 1));
                const moduleNode = moduleGraph?.idToModuleMap.get(path);
                if (moduleNode?.lastHMRTimestamp) {
                    manifest.raw = posix.join(resolvedConfig.base, `/${manifest.path}.js?t=${moduleNode.lastHMRTimestamp}`);
                }
                return manifest;
            });
        },
        transform(_code, id) {
            if (resolvedConfig.mode !== 'production')
                return;
            const manifest = settingsModules.get(id);
            return manifest ? { meta: { manifests: [manifest] } } : undefined;
        },
        generateBundle(_options, bundle) {
            if (!autoloadSettings)
                return;
            for (const file in bundle) {
                const chunk = bundle[file];
                if (chunk.type !== 'chunk' || !chunk.facadeModuleId)
                    continue;
                const meta = this.getModuleInfo(chunk.facadeModuleId)?.meta;
                if (!meta?.manifests)
                    continue;
                for (const manifest of meta.manifests) {
                    if (manifest.generator !== 'settings')
                        continue;
                    delete manifest.generator;
                    const requirements = getRequirements(this, chunk.facadeModuleId);
                    if (!requirements.length)
                        continue;
                    const requires = mergeRequirements(requirements);
                    if (requires)
                        manifest.requires = requires;
                }
            }
        }
    };
});
