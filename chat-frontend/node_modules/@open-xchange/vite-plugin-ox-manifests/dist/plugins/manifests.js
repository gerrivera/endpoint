import path from 'node:path';
import fs from 'node:fs';
import fastGlob from 'fast-glob';
import { definePlugin } from './plugin.js';
import { PROJECT_NAME, applyInputToOptions, basepath, joinUrlPaths, stringifyJSON } from '../util.js';
async function getManifestEntryFile(basePath, extensions) {
    if (path.extname(basePath)) {
        try {
            await fs.promises.stat(basePath);
            return path.parse(basePath);
        }
        catch {
            throw new Error(`Cannot find file "${basePath}"`);
        }
    }
    for (const ext of extensions) {
        try {
            await fs.promises.stat(`${basePath}.${ext}`);
            return path.parse(`${basePath}.${ext}`);
        }
        catch { }
    }
    throw new Error(`Cannot find file "${basePath}"`);
}
export default definePlugin(({ supportedEntryExtensions, entryPoints, manifestsAsEntryPoints }) => {
    const manifestModules = new Map();
    let resolvedConfig;
    let inputOptions;
    let viteManifestPlugin;
    let environment;
    async function buildViteManifests(options, bundle) {
        return new Promise((resolve, reject) => {
            // local async context to satisfy type checker expecting void callback for promise constructor
            (async function () {
                if (typeof viteManifestPlugin.buildStart !== 'function' || typeof viteManifestPlugin.generateBundle !== 'function') {
                    throw new Error(`${PROJECT_NAME}: missing required callbacks in plugin 'vite:manifest'`);
                }
                // fake `PluginContext` to be passed to Vite's manifest plugin, needed to extract the asset data
                const context = {
                    emitFile(file) {
                        if (file.type === 'asset' && typeof file.source === 'string') {
                            resolve(JSON.parse(file.source));
                        }
                        else {
                            reject(new Error(`${PROJECT_NAME}: received unexpected manifest data from plugin 'vite:manifest'`));
                        }
                    },
                    getFileName: () => 'Not implemented',
                    environment
                };
                // manually invoke plugin hooks (in a local async context to satisfy type checker expecting sync promise callbacks)
                await viteManifestPlugin.buildStart.call(context, inputOptions);
                await viteManifestPlugin.generateBundle.call(context, options, bundle, false);
            })().catch(reject);
        });
    }
    return {
        name: `${PROJECT_NAME}/manifests-plugin`,
        config(config) {
            (config.build ??= {}).manifest = true;
        },
        configResolved(config) {
            resolvedConfig = config;
            if (resolvedConfig.mode !== 'production')
                return;
            // extract the vite:manifest plugin from the list
            const index = config.plugins.findIndex(plugin => plugin.name === 'vite:manifest');
            viteManifestPlugin = config.plugins.splice(index, 1)[0];
        },
        async options(options) {
            const input = {};
            if (entryPoints) {
                const entryPointFiles = await fastGlob(entryPoints, { absolute: true });
                for (const entry of entryPointFiles) {
                    const baseLength = resolvedConfig.root.length + 1;
                    const extLength = path.extname(entry).length;
                    input[entry.substring(baseLength, entry.length - extLength)] = entry;
                }
            }
            // 1. load all json files
            const root = resolvedConfig.root;
            const entries = await fastGlob(`${root.replace(/\\/g, '/')}/**/manifest.json`);
            // 2. find every file that is referenced by that json file
            for (const entry of entries) {
                const rawData = await fs.promises.readFile(entry, 'utf-8');
                const json = JSON.parse(rawData);
                const manifests = Array.isArray(json) ? json : [json];
                const manifestDir = path.dirname(entry).substring(root.length + 1);
                await Promise.all(manifests.map(async ({ path: srcManifestEntryPath = joinUrlPaths(manifestDir, 'register'), ...rest }) => {
                    const { dir, base } = await getManifestEntryFile(joinUrlPaths(root, srcManifestEntryPath), supportedEntryExtensions);
                    const manifestEntryPath = joinUrlPaths(dir, base);
                    if (manifestsAsEntryPoints) {
                        input[basepath(joinUrlPaths(path.dirname(srcManifestEntryPath), base))] = manifestEntryPath;
                    }
                    // 3. put the file content except path into the manifest modules
                    const modules = manifestModules.get(manifestEntryPath);
                    manifestModules.set(manifestEntryPath, (modules || []).concat({ path: '', ...rest }));
                }));
            }
            if (resolvedConfig.mode === 'production') {
                applyInputToOptions(input, options);
            }
            return options;
        },
        buildStart(options) {
            inputOptions = options;
            environment = this.environment;
        },
        // specific call to collect all manifests
        getManifests() {
            return Array.from(manifestModules, ([path, manifests]) => manifests.map(m => ({ ...m, path: basepath(path.slice(resolvedConfig.root.length + 1)) }))).flat(1);
        },
        transform(_code, id) {
            if (resolvedConfig.mode !== 'production')
                return;
            const manifests = manifestModules.get(id);
            return manifests ? { meta: { manifests } } : undefined;
        },
        async generateBundle(options, bundle) {
            const viteManifests = await buildViteManifests(options, bundle);
            for (const entry in viteManifests) {
                const chunk = bundle[viteManifests[entry].file];
                if (chunk.type === 'chunk' && chunk.facadeModuleId) {
                    viteManifests[entry].meta = this.getModuleInfo(chunk.facadeModuleId)?.meta;
                }
            }
            this.emitFile({
                fileName: 'manifest.json',
                type: 'asset',
                source: stringifyJSON(resolvedConfig, viteManifests)
            });
        }
    };
});
