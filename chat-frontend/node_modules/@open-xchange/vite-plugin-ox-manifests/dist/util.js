import path from 'node:path';
import { normalizePath } from 'vite';
export const PROJECT_NAME = '@open-xchange/vite-plugin-ox-manifests';
export function applyInputToOptions(input, options) {
    // apply changes to input
    if (Object.keys(input).length > 0) {
        if (options.input) {
            if (typeof options.input === 'string') {
                input.index = options.input;
                options.input = input;
            }
            else if (Array.isArray(options.input)) {
                options.input = [...options.input, ...Object.values(input)];
            }
            else {
                Object.assign(input, options.input);
                options.input = input;
            }
        }
    }
}
export function joinUrlPaths(...paths) {
    return normalizePath(path.join(...paths));
}
export function basepath(src) {
    const { dir, name } = path.parse(src);
    return joinUrlPaths(dir, name);
}
export function deepMergeObject(a, b) {
    const keys = [...new Set([...Object.keys(a), ...Object.keys(b)])];
    const result = {};
    for (const key of keys) {
        if (a[key] === undefined)
            result[key] = b[key];
        else if (b[key] === undefined)
            result[key] = a[key];
        else if (Array.isArray(a[key]) !== Array.isArray(b[key]))
            throw new Error('Cannot merge different types');
        else if (typeof a[key] !== typeof b[key])
            throw new Error('Cannot merge different types');
        else if (Array.isArray(a[key]))
            result[key] = [...a[key], ...b[key]];
        else if (typeof a[key] === 'object')
            result[key] = deepMergeObject(a[key], b[key]);
        else
            result[key] = b[key];
    }
    return result;
}
export function mergeManifests(manifests) {
    const manifestsByHash = new Map();
    for (const manifest of manifests) {
        const hash = `${manifest.namespace}--${manifest.path}`;
        // overwrites existing ones. last wins
        manifestsByHash.set(hash, manifest);
    }
    return Array.from(manifestsByHash.values());
}
export function stringifyJSON({ build }, json) {
    return (build.minify === false) ? JSON.stringify(json, null, 2) : JSON.stringify(json);
}
export function waitForReload(server) {
    return new Promise(resolve => {
        const send = server.ws.send.bind(server.ws);
        server.ws.send = function (arg1, ...args) {
            try {
                send(arg1, ...args);
            }
            finally {
                if (typeof arg1 === 'object' && arg1.type === 'full-reload')
                    resolve();
            }
        };
    });
}
export async function wait(millis) {
    await new Promise(resolve => setTimeout(resolve, millis));
}
